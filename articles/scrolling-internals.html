<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Scrolling Internals | ProItemsRepeater for Avalonia </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Scrolling Internals | ProItemsRepeater for Avalonia ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/wieslawsoltes/ProItemsRepeater/blob/main/docfx/articles/scrolling-internals.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="scrolling-internals">Scrolling Internals</h1>

<p>This article explains how <code>ItemsRepeater</code> participates in scrolling without being a scroll viewer. It focuses on the internal coordination between <code>ItemsRepeater</code>, the layout system, and the parent scroller.</p>
<h2 id="itemsrepeater-is-not-a-scroll-viewer">ItemsRepeater is not a scroll viewer</h2>
<p><code>ItemsRepeater</code> derives from <code>Panel</code> and does not render scrollbars or manage input directly. It does implement <code>ILogicalScrollable</code>, so an ancestor scroll viewer (usually <code>ScrollViewer</code>) can delegate scroll offsets and viewport updates to it. Because of that:</p>
<ul>
<li>You must wrap <code>ItemsRepeater</code> in a scroll viewer to get scrolling.</li>
<li><code>ItemsRepeater</code> supplies virtualization and anchoring; the scroll viewer supplies scrollbars and input handling.</li>
</ul>
<h2 id="logical-scrolling-integration">Logical scrolling integration</h2>
<p>When hosted in a <code>ScrollViewer</code>, the repeater is detected as <code>ILogicalScrollable</code> and the scroll viewer switches to logical scrolling:</p>
<ul>
<li>The scroll viewer binds to <code>Extent</code>, <code>Viewport</code>, and <code>Offset</code> on the repeater.</li>
<li>Scroll input uses the repeater-provided logical step sizes (<code>ScrollSize</code> and <code>PageScrollSize</code>).</li>
<li>The child is not physically offset; the repeater updates its viewport through <code>ViewportManager.UpdateViewportFromLogicalScroll(...)</code>.</li>
</ul>
<p>If the repeater is not hosted in a scroll viewer, no logical scrolling occurs and viewport-driven virtualization is limited to layout-driven updates.</p>
<p>For a detailed breakdown of the <code>ILogicalScrollable</code> contract and how <code>ItemsRepeater</code> maps it, see <a href="logical-scrolling.html">Logical Scrolling (ILogicalScrollable)</a>.</p>
<p>If content does not implement <code>ILogicalScrollable</code> (or disables it), the scroll viewer uses physical scrolling. See <a href="physical-scrolling.html">Physical Scrolling (Non-Logical Mode)</a>.</p>
<h2 id="viewport-driven-virtualization">Viewport-driven virtualization</h2>
<p>When scrolling is available, <code>ItemsRepeater</code> tracks the <em>effective viewport</em> and uses it to compute:</p>
<ul>
<li>The <strong>visible window</strong>, which represents the on-screen viewport in layout coordinates.</li>
<li>The <strong>realization window</strong>, which is the visible window expanded by cache buffers.</li>
</ul>
<p>The realization window is the primary input to virtualization-aware layouts. Only items that intersect this window are realized (created and measured), which keeps UI generation proportional to what is visible.</p>
<h2 id="how-the-scroller-is-discovered">How the scroller is discovered</h2>
<p><code>ItemsRepeater</code> delegates viewport management to <code>ViewportManager</code>. The manager walks up the visual tree and looks for an <code>IScrollAnchorProvider</code> (usually <code>ScrollViewer</code>). When one is found, it:</p>
<ul>
<li>Subscribes to <code>EffectiveViewportChanged</code> to receive viewport updates.</li>
<li>Uses scroll anchoring to stabilize content across layout changes.</li>
</ul>
<p>If no scroller is found, the repeater still performs layout, but viewport-driven virtualization and anchoring are limited.</p>
<h2 id="measurearrange-integration">Measure/arrange integration</h2>
<p>The scrolling pipeline is integrated into layout passes:</p>
<ol>
<li><p><strong>Measure</strong>:</p>
<ul>
<li><code>ViewportManager</code> is notified at the start of measure.</li>
<li>The visible and realization windows are queried.</li>
<li>The layout measures only what intersects the realization window.</li>
<li>The layout extent is reported back to <code>ViewportManager</code>.</li>
</ul>
</li>
<li><p><strong>Arrange</strong>:</p>
<ul>
<li>Realized elements are arranged.</li>
<li><code>ViewportManager</code> registers realized elements as scroll anchor candidates.</li>
<li>Cache buffers are gradually expanded toward the configured cache lengths.</li>
</ul>
</li>
</ol>
<p>This keeps realized content stable while scrolling and ensures virtualization is consistent with the current viewport.</p>
<h2 id="cache-length-and-buffer-growth">Cache length and buffer growth</h2>
<p><code>ItemsRepeater.HorizontalCacheLength</code> and <code>ItemsRepeater.VerticalCacheLength</code> are multipliers of the current viewport size. They define how far the realization window extends beyond the visible window.</p>
<p>Instead of jumping directly to the full cache size, <code>ViewportManager</code> inflates the cache buffers in small steps per arrange. This reduces layout thrash while the user scrolls quickly and keeps memory usage predictable.</p>
<h2 id="scroll-anchoring-and-stability">Scroll anchoring and stability</h2>
<p>Scroll anchoring keeps the user's content from jumping when items are inserted, removed, or resized. <code>ViewportManager</code> registers realized children as anchor candidates with the scroller. The scroller chooses one anchor to keep stable as it adjusts offsets.</p>
<p>Anchoring is automatically disabled in some cases:</p>
<ul>
<li>Certain layouts (notably <code>WrapLayout</code>) can produce unstable anchoring; it is disabled to avoid incorrect jumps.</li>
<li>Large viewport jumps also disable anchoring temporarily to prevent locking to a stale anchor.</li>
</ul>
<h2 id="bring-into-view-behavior">Bring-into-view behavior</h2>
<p><code>ItemsRepeater</code> listens for <code>RequestBringIntoViewEvent</code> and forwards it to <code>ViewportManager</code>. The manager:</p>
<ul>
<li>Finds the immediate child of the repeater that is being brought into view.</li>
<li>Temporarily registers only that element as an anchor candidate.</li>
<li>Restores normal anchoring after rendering completes.</li>
</ul>
<p>This ensures the item being brought into view stays stable and becomes visible without being displaced by other anchors.</p>
<h2 id="non-virtualizing-layouts">Non-virtualizing layouts</h2>
<p>When the layout is non-virtualizing, viewport management is disabled. In that mode:</p>
<ul>
<li>Effective viewport updates are ignored.</li>
<li>The realization window is not used to drive element generation.</li>
<li>The repeater behaves like a normal panel that realizes all items.</li>
</ul>
<h2 id="practical-usage">Practical usage</h2>
<p>To enable virtualization and scrolling, combine <code>ItemsRepeater</code> with a scroll viewer and a virtualizing layout:</p>
<pre><code class="lang-xml">&lt;ScrollViewer HorizontalScrollBarVisibility=&quot;Auto&quot;
              VerticalScrollBarVisibility=&quot;Auto&quot;&gt;
  &lt;ItemsRepeater ItemsSource=&quot;{Binding Items}&quot;&gt;
    &lt;ItemsRepeater.Layout&gt;
      &lt;StackLayout Orientation=&quot;Vertical&quot; /&gt;
    &lt;/ItemsRepeater.Layout&gt;
  &lt;/ItemsRepeater&gt;
&lt;/ScrollViewer&gt;
</code></pre>
<p>To programmatically bring an item into view:</p>
<pre><code class="lang-csharp">var element = repeater.GetOrCreateElement(index);
element.BringIntoView();
</code></pre>
<p><code>GetOrCreateElement</code> realizes the item if needed, and the subsequent layout pass uses the viewport system to scroll it into view.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/wieslawsoltes/ProItemsRepeater/blob/main/docfx/articles/scrolling-internals.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
